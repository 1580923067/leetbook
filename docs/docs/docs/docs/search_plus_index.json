{"./":{"url":"./","title":"Introduction","keywords":"","body":" 介绍 介绍 leetcode地址： https://leetcode.com/ leetcode中国地址：https://leetcode-cn.com/ github地址：https://github.com/smbzhang/leetcode "},"chang-yong-shu-ju-jie-gou-shu-li.html":{"url":"chang-yong-shu-ju-jie-gou-shu-li.html","title":"常用数据结构梳理","keywords":"","body":" HashMap无序Map1. C++的hash_map & unordered_map1.1. 特性1.2. hash_table 与 Bucket1.3. 迭代器1.4. 构造方式1.5. 容量操作1.6. 元素操作1.7. 示例代码2. Go的hashmap2.1. 特性2.2. 构造方式2.3. 元素操作2.4. 容量2.5. 查找2.6. 删除（如果key不存在不会报错）2.7. 遍历2.8. 注意坑3. Python的hashmap3.1. 构造方式3.2. 元素访问3.3. 查找3.4. 删除字典元素3.5. 容量3.6. 遍历 HashMap无序Map 1. C++的hash_map & unordered_map 这两个的内部结构都是使用哈希表来实现的，区别是 unordered_map 在 C++11中被引入标准库了。 1.1. 特性 关联性：通过key去检索value，而不是通过绝对地址（和顺序容器不同） 无序性：使用hash表存储，内部无序 Map : 每个值对应一个键值 键唯一性：不存在两个元素的键一样 动态内存管理：使用内存管理模型来动态管理所需要的内存空间 1.2. hash_table 与 Bucket unorderedmap的内部是使用 hashtable 数据结构存储的，hash就会存在冲突，关于怎么处理冲突可以去看一下STL源码剖析这本书。 当出现冲突的时候会通过链表连在前一个元素后面，这个位置被称为bucket 所以unordered_map内部其实是由很多哈希桶组成的，每个哈希桶中可能没有元素，也可能有多个元素。 1.3. 迭代器 unordered_map的迭代器是一个指针，指向这个元素，通过迭代器来取得它的值。 unordered_map::iterator it; (*it).first; // the key value (of type Key) (*it).second; // the mapped value (of type T) (*it); // the \"element value\" (of type pair) 它的键值分别是迭代器的first和second属性。 it->first; // same as (*it).first (the key value) it->second; // same as (*it).second (the mapped value) 1.4. 构造方式 - 构造空的容器 - 复制构造 - 范围构造 - 用数组构造 typedef unordered_map stringmap; int main () { stringmap first; // 空 stringmap second ( {{\"apple\",\"red\"},{\"lemon\",\"yellow\"}} ); // 用数组初始 stringmap fourth (second); // 复制初始化 stringmap sixth (second.begin(),second.end()); // 范围初始化 for (auto& x: sixth) cout 1.5. 容量操作 empty bool empty() const noexcept; size size_type size() const noexcept; 1.6. 元素操作 find iterator find ( const key_type& k ); 查找key所在的元素。 找到：返回元素的迭代器。通过迭代器的second属性获取值 没找到：返回unordered_map::end insert 插入有几种方式： 复制插入 (复制一个已有的pair的内容) 数组插入（直接插入一个二维数组） 范围插入（复制一个起始迭代器和终止迭代器中间的内容） 数组访问模式插入(和数组的[]操作很相似) 具体看后面的例子 at mapped_type& at ( const key_type& k ); 查找key所对应的值 如果存在：返回key对应的值，可以直接修改，和[]操作一样。 如果不存在：抛出 out_of_range 异常. erase 擦除元素也有几种方式： 1. 通过位置（迭代器） iterator erase ( const_iterator position ); 2. 通过key size_type erase ( const key_type& k ); 3. 通过范围（两个迭代器） iterator erase ( const_iterator first, const_iterator last ); clear void clear() noexcept 清空unordered_map swap void swap ( unordered_map& ump ); 交换两个unordered_map（注意，不是交换特定元素，是整个交换两个map中的所有元素） 1.7. 示例代码 // unordered_map::insert #include #include #include using namespace std; void display(unordered_map myrecipe,string str) { cout myrecipe, mypantry = {{\"milk\",2.0},{\"flour\",1.5}}; /****************插入*****************/ pair myshopping (\"baking powder\",0.3); myrecipe.insert (myshopping); // 复制插入 myrecipe.insert (make_pair(\"eggs\",6.0)); // 移动插入 myrecipe.insert (mypantry.begin(), mypantry.end()); // 范围插入 myrecipe.insert ({{\"sugar\",0.8},{\"salt\",0.1}}); // 初始化数组插入(可以用二维一次插入多个元素，也可以用一维插入一个元素) myrecipe[\"coffee\"] = 10.0; //数组形式插入 display(myrecipe,\"myrecipe contains:\"); /****************查找*****************/ unordered_map::const_iterator got = myrecipe.find (\"coffee\"); if ( got == myrecipe.end() ) cout first second2. Go的hashmap Go语言的map数据结构就是hashmap 2.1. 特性 Go语言的map底层的实现和C++的实现原理相同，同样是基于bucket来实现内存管理的。Go语言中的map和slice以及channel一样是引用类型。键必须是支持相等运算符 (\"==\"、\"!=\") 类型， 如 number、string、 pointer、array、struct，以及对应的 interface。值可以是任意类型，没有限制。slice，map，function都不能当做key。 2.2. 构造方式 1. 直接构造 var m1 map[string]float32 = map[string]float32{\"C\": 5, \"Go\": 4.5, \"Python\": 4.5, \"C++\": 2} 2. make构造 // 创建了一个键类型为string,值类型为int的map m1 := make(map[string]int) // 也可以选择是否在创建时指定该map的初始存储能力，如创建了一个初始存储能力为5的map m2 := make(map[string]int, 5) 2.3. 元素操作 m := map[string]string{\"key0\": \"value0\", \"key1\": \"value1\"} fmt.Printf(\"map m : %v\\n\", m) //map插入 m[\"key2\"] = \"value2\" fmt.Printf(\"inserted map m : %v\\n\", m) //map修改 m[\"key0\"] = \"hello world!\" fmt.Printf(\"updated map m : %v\\n\", m) 2.4. 容量 获取键值对的数量 builtin.len len := len(m) // cap 无效，error // cap := cap(m) //invalid argument m (type map[string]string) for cap // fmt.Printf(\"map's cap is %v\\n\", cap) map的容量只能通过len来进行计算，不能使用cap计算容量 2.5. 查找 val, ok := m[\"key0\"] if ok { fmt.Printf(\"map's key0 is %v\\n\", val) } 通过返回值来进行查找，返回的ok如果是true查找成功，false查找失败 2.6. 删除（如果key不存在不会报错） delete if val, ok = m[\"key1\"]; ok { delete(m, \"key1\") fmt.Printf(\"deleted key1 map m : %v\\n\", m) } 因为key 不存在的时候删除操作不会报错所以需要先进行存在判断 2.7. 遍历 for k, v := range m { fmt.Printf(\"key -> value : %v -> %v\\n\", k, v) } 2.8. 注意坑 从 map 中取回的是一个 value 临时复制品，对其成员的修改是没有任何意义的。 func main() { m := map[int]string{1: \"x\", 2: \"w\"} fmt.Println(m) for k, v := range m { m[k] = v + v //修改map的值 v = v + \"copy\" //临时复制品，修改无效 } fmt.Println(m) } 容器和结构体（map and struct） 语法比较： map[type]struct map[type]*struct func main() { type user struct{ name string } /* 当 map 因扩张而重新哈希时，各键值项存储位置都会发生改变。 因此，map 被设计成 not addressable。 类似 m[1].name 这种期望透过原 value 指针修改成员的行为自然会被禁 。 */ m := map[int]user{ // 1: {\"user1\"}, } // m[1].name = \"Tom\" // ./main.go:16:12: cannot assign to struct field m[1].name in map fmt.Println(m) // 正确做法是完整替换 value 或使用指针。 u := m[1] u.name = \"Tom\" m[1] = u // 替换 value。 m2 := map[int]*user{ 1: &user{\"user1\"}, } m2[1].name = \"Jack\" // 返回的是指针复制品。透过指针修改原对象是允许的。 fmt.Println(m2) } 可以在迭代时安全删除键值。但如果期间有新增操作，那么就不知道会有什么意外了。 func main() { for i := 0; i 3. Python的hashmap 同样的python中的字典也是hashmap，实现的方式也是和C++相同。键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一。键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行。 3.1. 构造方式 dict = {'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'} dict = {} 因为python是弱类型语言，所以直接构造方式即可 3.2. 元素访问 如果key值不存在就会抛异常 3.3. 查找 dict.has_key(key) 有则返回True，否则返回False 3.4. 删除字典元素 del dict['Name'] # 删除键是'Name'的条目 dict.clear() # 清空字典所有条目 del dict # 删除字典 删除不存在的key值，会抛出异常 3.5. 容量 len(dict) 使用len函数进行容量的计算 3.6. 遍历 dict={\"a\":\"Alice\",\"b\":\"Bruce\",\"J\":\"Jack\"} # 实例一： for i in dict: print \"dict[%s]=\" % i,dict[i] # 实例二： for i in dict.items(): print i # 实例三： for (k,v) in dict.items(): print \"dict[%s]=\" % k,v # 实例四： for k,v in dict.iteritems(): print \"dict[%s]=\" % k,v # 实例五: for k in dict.keys(): print key 遍历的方式非常的多 "},"chapter1.html":{"url":"chapter1.html","title":"LeetCode_1_Two_Sum","keywords":"","body":"1. 题目描述（简单难度）2. 解法一2.1. C++实现2.2. Go实现2.3. Python实现3. 解法二3.1. C++实现4. 总结1. 题目描述（简单难度） Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 2. 解法一 简单粗暴，两重循环，外层遍历下标 i：[0，n - 1)，内层 j：[i + 1，n - 1]。n是数组的长度 2.1. C++实现 class Solution { public: vector twoSum(vector& nums, int target) { vector result; int n = nums.size(); for (int i = 0; i 2.2. Go实现 func twoSum(nums []int, target int) []int { var ret []int for i := 0; i 2.3. Python实现 class Solution(object): def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" ret = [] n = len(nums) for i in range(0, n - 1): for j in range(i + 1, n): if nums[i] + nums[j] == target: ret.append(i) ret.append(j) return ret return ret 时间复杂度：两层 for 循环，O（n²） 空间复杂度：O（1） 3. 解法二 第二个循环是为了找出 target-nums[i] 的值，代替循环我们可以使用hash map来存储数组信息 key：数组的值 value：数组的下标 3.1. C++实现 class Solution2 { public: vector twoSum(vector& nums, int target) { vector result; int n = nums.size(); std::unordered_map hmap; for (int i = 0; i second != i) { result.emplace_back(i); result.emplace_back(iter->second); break; } } return result; } }; 空间换时间，额外使用了一个 4. 总结 "},"leetcode2-addtwo-numbers.html":{"url":"leetcode2-addtwo-numbers.html","title":"LeetCode_2_Add_Two_Numbers","keywords":"","body":"1. 题目描述（中等难度）2. 思路3. 代码3.1. C++实现3.2. python实现3.3. Go实现1. 题目描述（中等难度） 2. 思路 这个题就是一个大数加法题，两个链表表示两个大数字，不过链表的节点是按照数字的低位到高位进行排列的，所以我们从头遍历两个链表并把结点值相加，进位用carry表示。伪代码如下： 1. 初始化两个NULL节点 pcur 和 ret， ret用来返回结果链表，pcur指向当前操作的结果链表节点 2. 初始化一个int类型的进位值 carry = 0 3. 初始化两个int类型的值，表示当前两个链表的当前元素的值， num1 = 0 num2 = 0 4. while(l1 != NULL || l2 != NULL) 1. num1 = (l1 == NULL) ? 0 : l1->val 2. num2 = (l2 == NULL) ? 0 : l2->val 3. 计算 mod = num1 + num2 + carry % 10 4. 计算 carry = num1 + num2 + carry / 10 如果 pcur 等于 NULL 5. 新建一个 node 节点，使用 mod 初始化， 并且 pcur 指向这个节点， ret = pcur 初始化返回列表头 否则的话 5. 新建一个 node 节点，使用 mod 初始化， 并且 pcur->next 指向这个节点, pcur = node 6. 判断 l1 和 l2 是否为 NULL 并向前移动一个节点 5. 判断 carry 是不是0，如果不是的话，创建一个节点node使用carry初始化，pcur指向这个node 6. 返回 ret 时间复杂度 O(n) 空间复杂度O(1) 3. 代码 3.1. C++实现 下面两个其实实现是一样的，只不过第一个没有使用 num1和num2来进行设计，所以写出来的程序很丑陋。 class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *pcur1 = l1, *pcur2 = l2, *pcur = NULL, *ret = NULL; int carry = 0; while (pcur1 != NULL) { int num1 = pcur1->val; if (pcur2 != NULL) { int num2 = pcur2->val; int mod = (num1 + num2 + carry) % 10; if (pcur == NULL) { pcur = new ListNode(mod); ret = pcur; }else { ListNode *node = new ListNode(mod); pcur->next = node; pcur = node; } carry = (num1 + num2 + carry) / 10; pcur2 = pcur2->next; }else break; pcur1 = pcur1->next; } while(pcur1 != NULL) { int mod = (pcur1->val + carry) % 10; carry = (pcur1->val + carry) / 10; ListNode *node = new ListNode(mod); pcur->next = node; pcur = node; pcur1 = pcur1->next; } while(pcur2 != NULL) { int mod = (pcur2->val + carry) % 10; carry = (pcur2->val + carry) / 10; ListNode *node = new ListNode(mod); pcur->next = node; pcur = node; pcur2 = pcur2->next; } if (carry != 0) { ListNode *node = new ListNode(carry); pcur->next = node; pcur = node; } return ret; } }; class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *ret = NULL, *pcur = NULL; int num1 = 0, num2 = 0, carry = 0; while (l1 != NULL || l2 != NULL) { num1 = (l1 == NULL) ? 0 : l1->val; num2 = (l2 == NULL) ? 0 : l2->val; int mod = (num1 + num2 + carry) % 10; carry = (num1 + num2 + carry) / 10; ListNode *node = new ListNode(mod); if (pcur == NULL) { pcur = node; ret = pcur; } else { pcur->next = node; pcur = node; } if (l1 != NULL) l1 = l1->next; if (l2 != NULL) l2 = l2->next; } if (carry != 0) { ListNode *node = new ListNode(carry); pcur->next = node; } return ret; } }; 3.2. python实现 class Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" ret = None pcur = ret num1 = 0 num2 = 0 carry = 0 while l1 != None or l2 != None : if l1 == None: num1 = 0 else: num1 = l1.val if l2 == None: num2 = 0 else: num2 = l2.val mod = (num1 + num2 + carry) % 10 carry = (num1 + num2 + carry) / 10 node = ListNode(mod) if pcur == None: pcur = node ret = pcur else: pcur.next = node pcur = node if l1 != None: l1 = l1.next if l2 != None: l2 = l2.next if carry != 0: node = ListNode(carry) pcur.next = node return ret 3.3. Go实现 func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { var pcur, ret *ListNode = nil, nil var num1, num2, carry int = 0, 0, 0 for l1 != nil || l2 != nil { if (l1 == nil) {num1 = 0} else {num1 = l1.Val} if (l2 == nil) {num2 = 0} else {num2 = l2.Val} mod := (num1 + num2 + carry) % 10 carry = (num1 + num2 + carry) / 10 node := new(ListNode) node.Val = mod node.Next = nil if (pcur == nil) { pcur = node ret = node }else { pcur.Next = node pcur = node } if (l1 != nil) {l1 = l1.Next} if (l2 != nil) {l2 = l2.Next} } if (carry != 0) { node := new(ListNode) node.Val = carry node.Next = nil pcur.Next = node } return ret } "}}