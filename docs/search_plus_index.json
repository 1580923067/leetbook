{"./":{"url":"./","title":"Introduction","keywords":"","body":" 介绍 介绍 leetcode地址： https://leetcode.com/ leetcode中国地址：https://leetcode-cn.com/ github地址：https://github.com/smbzhang/leetcode "},"DataStruct.html":{"url":"DataStruct.html","title":"常用数据结构梳理","keywords":"","body":" HashMap无序Map1. C++的hash_map & unordered_map1.1. 特性1.2. hash_table 与 Bucket1.3. 迭代器1.4. 构造方式1.5. 容量操作1.6. 元素操作1.7. 示例代码2. Go的hashmap2.1. 特性2.2. 构造方式2.3. 元素操作2.4. 容量2.5. 查找2.6. 删除（如果key不存在不会报错）2.7. 遍历2.8. 注意坑3. Python的hashmap3.1. 构造方式3.2. 元素访问3.3. 查找3.4. 删除字典元素3.5. 容量3.6. 遍历 HashMap无序Map 1. C++的hash_map & unordered_map 这两个的内部结构都是使用哈希表来实现的，区别是 unordered_map 在 C++11中被引入标准库了。 1.1. 特性 关联性：通过key去检索value，而不是通过绝对地址（和顺序容器不同） 无序性：使用hash表存储，内部无序 Map : 每个值对应一个键值 键唯一性：不存在两个元素的键一样 动态内存管理：使用内存管理模型来动态管理所需要的内存空间 1.2. hash_table 与 Bucket unorderedmap的内部是使用 hashtable 数据结构存储的，hash就会存在冲突，关于怎么处理冲突可以去看一下STL源码剖析这本书。 当出现冲突的时候会通过链表连在前一个元素后面，这个位置被称为bucket 所以unordered_map内部其实是由很多哈希桶组成的，每个哈希桶中可能没有元素，也可能有多个元素。 1.3. 迭代器 unordered_map的迭代器是一个指针，指向这个元素，通过迭代器来取得它的值。 unordered_map::iterator it; (*it).first; // the key value (of type Key) (*it).second; // the mapped value (of type T) (*it); // the \"element value\" (of type pair) 它的键值分别是迭代器的first和second属性。 it->first; // same as (*it).first (the key value) it->second; // same as (*it).second (the mapped value) 1.4. 构造方式 - 构造空的容器 - 复制构造 - 范围构造 - 用数组构造 {% raw %} typedef unordered_map stringmap; int main () { stringmap first; // 空 stringmap second ({{\"apple\",\"red\"},{\"lemon\",\"yellow\"}}); // 用数组初始 stringmap fourth (second); // 复制初始化 stringmap sixth (second.begin(),second.end()); // 范围初始化 for (auto& x: sixth) cout 1.5. 容量操作 empty bool empty() const noexcept; size size_type size() const noexcept; 1.6. 元素操作 find iterator find ( const key_type& k ); 查找key所在的元素。 找到：返回元素的迭代器。通过迭代器的second属性获取值 没找到：返回unordered_map::end insert 插入有几种方式： 复制插入 (复制一个已有的pair的内容) 数组插入（直接插入一个二维数组） 范围插入（复制一个起始迭代器和终止迭代器中间的内容） 数组访问模式插入(和数组的[]操作很相似) 具体看后面的例子 at mapped_type& at ( const key_type& k ); 查找key所对应的值 如果存在：返回key对应的值，可以直接修改，和[]操作一样。 如果不存在：抛出 out_of_range 异常. erase 擦除元素也有几种方式： 1. 通过位置（迭代器） iterator erase ( const_iterator position ); 2. 通过key size_type erase ( const key_type& k ); 3. 通过范围（两个迭代器） iterator erase ( const_iterator first, const_iterator last ); clear void clear() noexcept 清空unordered_map swap void swap ( unordered_map& ump ); 交换两个unordered_map（注意，不是交换特定元素，是整个交换两个map中的所有元素） 1.7. 示例代码 {% raw %} // unordered_map::insert #include #include #include using namespace std; void display(unordered_map myrecipe,string str) { cout myrecipe, mypantry = { {\"milk\",2.0}, {\"flour\",1.5} }; /****************插入*****************/ pair myshopping (\"baking powder\",0.3); myrecipe.insert (myshopping); // 复制插入 myrecipe.insert (make_pair(\"eggs\",6.0)); // 移动插入 myrecipe.insert (mypantry.begin(), mypantry.end()); // 范围插入 myrecipe.insert ({{\"sugar\",0.8},{\"salt\",0.1}}); // 初始化数组插入(可以用二维一次插入多个元素，也可以用一维插入一个元素) myrecipe[\"coffee\"] = 10.0; //数组形式插入 display(myrecipe,\"myrecipe contains:\"); /****************查找*****************/ unordered_map::const_iterator got = myrecipe.find (\"coffee\"); if ( got == myrecipe.end() ) cout first second2. Go的hashmap Go语言的map数据结构就是hashmap 2.1. 特性 Go语言的map底层的实现和C++的实现原理相同，同样是基于bucket来实现内存管理的。Go语言中的map和slice以及channel一样是引用类型。键必须是支持相等运算符 (\"==\"、\"!=\") 类型， 如 number、string、 pointer、array、struct，以及对应的 interface。值可以是任意类型，没有限制。slice，map，function都不能当做key。 2.2. 构造方式 1. 直接构造 var m1 map[string]float32 = map[string]float32{\"C\": 5, \"Go\": 4.5, \"Python\": 4.5, \"C++\": 2} 2. make构造 // 创建了一个键类型为string,值类型为int的map m1 := make(map[string]int) // 也可以选择是否在创建时指定该map的初始存储能力，如创建了一个初始存储能力为5的map m2 := make(map[string]int, 5) 2.3. 元素操作 m := map[string]string{\"key0\": \"value0\", \"key1\": \"value1\"} fmt.Printf(\"map m : %v\\n\", m) //map插入 m[\"key2\"] = \"value2\" fmt.Printf(\"inserted map m : %v\\n\", m) //map修改 m[\"key0\"] = \"hello world!\" fmt.Printf(\"updated map m : %v\\n\", m) 2.4. 容量 获取键值对的数量 builtin.len len := len(m) // cap 无效，error // cap := cap(m) //invalid argument m (type map[string]string) for cap // fmt.Printf(\"map's cap is %v\\n\", cap) map的容量只能通过len来进行计算，不能使用cap计算容量 2.5. 查找 val, ok := m[\"key0\"] if ok { fmt.Printf(\"map's key0 is %v\\n\", val) } 通过返回值来进行查找，返回的ok如果是true查找成功，false查找失败 2.6. 删除（如果key不存在不会报错） delete if val, ok = m[\"key1\"]; ok { delete(m, \"key1\") fmt.Printf(\"deleted key1 map m : %v\\n\", m) } 因为key 不存在的时候删除操作不会报错所以需要先进行存在判断 2.7. 遍历 for k, v := range m { fmt.Printf(\"key -> value : %v -> %v\\n\", k, v) } 2.8. 注意坑 从 map 中取回的是一个 value 临时复制品，对其成员的修改是没有任何意义的。 func main() { m := map[int]string{1: \"x\", 2: \"w\"} fmt.Println(m) for k, v := range m { m[k] = v + v //修改map的值 v = v + \"copy\" //临时复制品，修改无效 } fmt.Println(m) } 容器和结构体（map and struct） 语法比较： map[type]struct map[type]*struct func main() { type user struct{ name string } /* 当 map 因扩张而重新哈希时，各键值项存储位置都会发生改变。 因此，map 被设计成 not addressable。 类似 m[1].name 这种期望透过原 value 指针修改成员的行为自然会被禁 。 */ m := map[int]user{ // 1: {\"user1\"}, } // m[1].name = \"Tom\" // ./main.go:16:12: cannot assign to struct field m[1].name in map fmt.Println(m) // 正确做法是完整替换 value 或使用指针。 u := m[1] u.name = \"Tom\" m[1] = u // 替换 value。 m2 := map[int]*user{ 1: &user{\"user1\"}, } m2[1].name = \"Jack\" // 返回的是指针复制品。透过指针修改原对象是允许的。 fmt.Println(m2) } 可以在迭代时安全删除键值。但如果期间有新增操作，那么就不知道会有什么意外了。 func main() { for i := 0; i 3. Python的hashmap 同样的python中的字典也是hashmap，实现的方式也是和C++相同。键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一。键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行。 3.1. 构造方式 dict = {'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'} dict = {} 因为python是弱类型语言，所以直接构造方式即可 3.2. 元素访问 如果key值不存在就会抛异常 3.3. 查找 dict.has_key(key) 有则返回True，否则返回False 3.4. 删除字典元素 del dict['Name'] # 删除键是'Name'的条目 dict.clear() # 清空字典所有条目 del dict # 删除字典 删除不存在的key值，会抛出异常 3.5. 容量 len(dict) 使用len函数进行容量的计算 3.6. 遍历 dict={\"a\":\"Alice\",\"b\":\"Bruce\",\"J\":\"Jack\"} # 实例一： for i in dict: print \"dict[%s]=\" % i,dict[i] # 实例二： for i in dict.items(): print i # 实例三： for (k,v) in dict.items(): print \"dict[%s]=\" % k,v # 实例四： for k,v in dict.iteritems(): print \"dict[%s]=\" % k,v # 实例五: for k in dict.keys(): print key 遍历的方式非常的多 "},"001-TwoSum.html":{"url":"001-TwoSum.html","title":"001-TwoSum","keywords":"","body":"1. 题目描述（简单难度）2. 解法一2.1. C++实现2.2. Go实现2.3. Python实现3. 解法二3.1. C++实现4. 总结1. 题目描述（简单难度） Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 2. 解法一 简单粗暴，两重循环，外层遍历下标 i：[0，n - 1)，内层 j：[i + 1，n - 1]。n是数组的长度 2.1. C++实现 class Solution { public: vector twoSum(vector& nums, int target) { vector result; int n = nums.size(); for (int i = 0; i 2.2. Go实现 func twoSum(nums []int, target int) []int { var ret []int for i := 0; i 2.3. Python实现 class Solution(object): def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" ret = [] n = len(nums) for i in range(0, n - 1): for j in range(i + 1, n): if nums[i] + nums[j] == target: ret.append(i) ret.append(j) return ret return ret 时间复杂度：两层 for 循环，O（n²） 空间复杂度：O（1） 3. 解法二 第二个循环是为了找出 target-nums[i] 的值，代替循环我们可以使用hash map来存储数组信息 key：数组的值 value：数组的下标 3.1. C++实现 class Solution2 { public: vector twoSum(vector& nums, int target) { vector result; int n = nums.size(); std::unordered_map hmap; for (int i = 0; i second != i) { result.emplace_back(i); result.emplace_back(iter->second); break; } } return result; } }; 空间换时间，额外使用了一个 4. 总结 "},"002-AddTwoNumbers.html":{"url":"002-AddTwoNumbers.html","title":"002-AddTwoNumbers","keywords":"","body":"1. 题目描述（中等难度）2. 思路3. 代码3.1. C++实现3.2. python实现3.3. Go实现1. 题目描述（中等难度） 2. 思路 这个题就是一个大数加法题，两个链表表示两个大数字，不过链表的节点是按照数字的低位到高位进行排列的，所以我们从头遍历两个链表并把结点值相加，进位用carry表示。伪代码如下： 1. 初始化两个NULL节点 pcur 和 ret， ret用来返回结果链表，pcur指向当前操作的结果链表节点 2. 初始化一个int类型的进位值 carry = 0 3. 初始化两个int类型的值，表示当前两个链表的当前元素的值， num1 = 0 num2 = 0 4. while(l1 != NULL || l2 != NULL) 1. num1 = (l1 == NULL) ? 0 : l1->val 2. num2 = (l2 == NULL) ? 0 : l2->val 3. 计算 mod = num1 + num2 + carry % 10 4. 计算 carry = num1 + num2 + carry / 10 如果 pcur 等于 NULL 5. 新建一个 node 节点，使用 mod 初始化， 并且 pcur 指向这个节点， ret = pcur 初始化返回列表头 否则的话 5. 新建一个 node 节点，使用 mod 初始化， 并且 pcur->next 指向这个节点, pcur = node 6. 判断 l1 和 l2 是否为 NULL 并向前移动一个节点 5. 判断 carry 是不是0，如果不是的话，创建一个节点node使用carry初始化，pcur指向这个node 6. 返回 ret 时间复杂度 O(n) 空间复杂度O(1) 3. 代码 3.1. C++实现 下面两个其实实现是一样的，只不过第一个没有使用 num1和num2来进行设计，所以写出来的程序很丑陋。 class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *pcur1 = l1, *pcur2 = l2, *pcur = NULL, *ret = NULL; int carry = 0; while (pcur1 != NULL) { int num1 = pcur1->val; if (pcur2 != NULL) { int num2 = pcur2->val; int mod = (num1 + num2 + carry) % 10; if (pcur == NULL) { pcur = new ListNode(mod); ret = pcur; }else { ListNode *node = new ListNode(mod); pcur->next = node; pcur = node; } carry = (num1 + num2 + carry) / 10; pcur2 = pcur2->next; }else break; pcur1 = pcur1->next; } while(pcur1 != NULL) { int mod = (pcur1->val + carry) % 10; carry = (pcur1->val + carry) / 10; ListNode *node = new ListNode(mod); pcur->next = node; pcur = node; pcur1 = pcur1->next; } while(pcur2 != NULL) { int mod = (pcur2->val + carry) % 10; carry = (pcur2->val + carry) / 10; ListNode *node = new ListNode(mod); pcur->next = node; pcur = node; pcur2 = pcur2->next; } if (carry != 0) { ListNode *node = new ListNode(carry); pcur->next = node; pcur = node; } return ret; } }; class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *ret = NULL, *pcur = NULL; int num1 = 0, num2 = 0, carry = 0; while (l1 != NULL || l2 != NULL) { num1 = (l1 == NULL) ? 0 : l1->val; num2 = (l2 == NULL) ? 0 : l2->val; int mod = (num1 + num2 + carry) % 10; carry = (num1 + num2 + carry) / 10; ListNode *node = new ListNode(mod); if (pcur == NULL) { pcur = node; ret = pcur; } else { pcur->next = node; pcur = node; } if (l1 != NULL) l1 = l1->next; if (l2 != NULL) l2 = l2->next; } if (carry != 0) { ListNode *node = new ListNode(carry); pcur->next = node; } return ret; } }; 3.2. python实现 class Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" ret = None pcur = ret num1 = 0 num2 = 0 carry = 0 while l1 != None or l2 != None : if l1 == None: num1 = 0 else: num1 = l1.val if l2 == None: num2 = 0 else: num2 = l2.val mod = (num1 + num2 + carry) % 10 carry = (num1 + num2 + carry) / 10 node = ListNode(mod) if pcur == None: pcur = node ret = pcur else: pcur.next = node pcur = node if l1 != None: l1 = l1.next if l2 != None: l2 = l2.next if carry != 0: node = ListNode(carry) pcur.next = node return ret 3.3. Go实现 func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { var pcur, ret *ListNode = nil, nil var num1, num2, carry int = 0, 0, 0 for l1 != nil || l2 != nil { if (l1 == nil) {num1 = 0} else {num1 = l1.Val} if (l2 == nil) {num2 = 0} else {num2 = l2.Val} mod := (num1 + num2 + carry) % 10 carry = (num1 + num2 + carry) / 10 node := new(ListNode) node.Val = mod node.Next = nil if (pcur == nil) { pcur = node ret = node }else { pcur.Next = node pcur = node } if (l1 != nil) {l1 = l1.Next} if (l2 != nil) {l2 = l2.Next} } if (carry != 0) { node := new(ListNode) node.Val = carry node.Next = nil pcur.Next = node } return ret } "},"003-LongestSubstringWithoutRepeatingCharacters.html":{"url":"003-LongestSubstringWithoutRepeatingCharacters.html","title":"003-LongestSubstringWithoutRepeatingCharacters","keywords":"","body":"1. 题目描述（中等难度）2. 思路3. 代码3.1. C++实现3.2. Go语言实现3.3. Python实现1. 题目描述（中等难度） 这个题让找出最长的子串，该子串里面没有重复的字母 2. 思路 看到这个题，首先想到的是动态规划来解，求出以i开头的最长无重复子串，从这些子串中找出最长的。其中以i开头的最长无重复子串是和以i+1开始的最长无重复子串有相应关系的，可以列出递推公式。 1. 循环求出以i开头的最长无重复子串长度 2. 根据递推公式写出计算以i开头的无重复子串的最大长度程序。 3. 代码 3.1. C++实现 //动态规划递归求解, Memory Limit Exceeded class Solution { public: int lengthOfLongestSubstring(string s) { int max = 0; for (int i = 0 ; i max) ? len : max; } return max; } int lengthOfTheFirstSub(string str, int index) { string s = str.substr(index); if (s.length() 使用最简单的递归实现动态规划算法，leetcode显示内存超出限制，递归深度太高了，对于非常长的字符串。 //加入记录数组，提升查找速度, Memory Limit Exceeded 一定程度上解决内存问题 class Solution { public: int lengthOfLongestSubstring(string s) { int max = 0; std::vector records(s.length(), -1); for (int i = 0 ; i max) ? len : max; } return max; } int lengthOfTheFirstSub(string str, int index, std::vector &records) { if (records[index] != -1) {return records[index];} string s = str.substr(index); if (s.length() 上面的程序通过加入记录数组来解决每次递归都重新计算重复的以i开头的最长无重复子串，这样可以减少递归的深度，并且减少时间复杂度。很遗憾对于长字符串还是内存超限了，所以我们必须干掉递归程序 // 改成递推求解，减少栈内存消耗 class Solution { public: int lengthOfLongestSubstring(string s) { int n = s.length(); std::vector records(n, 0); if (n = 0; i--) { if (s[i] == s[i + 1]) { records[i] = 1; }else{ int index = s.substr(i + 1, records[i + 1]).find(s[i]); if (index == string::npos) { records[i] = records[i + 1] + 1; }else { records[i] = index + 1; } } } int max = 0; for (int i = 0; i max) { max = records[i]; } } return max; } }; 改造成递推求解，这样时间复杂度就是O(n), 空间复杂度也是O(n)，顺利通过leetcode检查 3.2. Go语言实现 func lengthOfLongestSubstring(s string) int { n := len(s) if (n = 0; i-- { if (s[i] == s[i + 1]) { records[i] = 1; }else{ if (!strings.Contains(s[i + 1: i + 1 + records[i +1]], string(s[i]))) { records[i] = records[i + 1] + 1; }else { index := strings.Index(s[i + 1: i + 1 + records[i +1]], string(s[i])) records[i] = index + 1 } } } max := 0 for _, num := range(records) { if num > max {max = num} } return max } 3.3. Python实现 class Solution(object): def lengthOfLongestSubstring(self, s): \"\"\" :type s: str :rtype: int \"\"\" n = len(s) if n max: max = records[i] return max "},"004-MedianOfTwoSortedArrays.html":{"url":"004-MedianOfTwoSortedArrays.html","title":"*004-MedianOfTwoSortedArrays","keywords":"","body":"1. 题目描述（困难难度）2. 思路1. 题目描述（困难难度） https://leetcode.com/problems/median-of-two-sorted-arrays/ 给定两个排序好的数组，找出其中的中位数。时间复杂度是 O(log(m+n)) 2. 思路 这个题目的难点在 O(log(m+n))的时间复杂度。看到这个时间复杂度首先想到的是使用二分法来解决。拼接两个数组然后使用二分法解决，但是这样的话拼接两个字符串的时间复杂度就是 O(m+n)已经超出限制了。 这也就意味着我们必须在不合并两个数组的情况下进行二分查找，或者找寻其他的解决办法了。 "},"005-LongestPalindromicSubstring.html":{"url":"005-LongestPalindromicSubstring.html","title":"005-LongestPalindromicSubstring","keywords":"","body":"1. 题目描述（中等难度）2. 思路3. 代码3.1. C++实现4. 总结1. 题目描述（中等难度） https://leetcode.com/problems/longest-palindromic-substring/ 最长回文子串，这个题是非常经典的一个题。 2. 思路 最长回文子串的解有三种方法。另外还有一种变种解法。 马拉车算法 （没搞懂） 中心扩展法 中心扩展法的核心思想就是，遍历所有的字符，并且以该字符为中心向外扩展，并且判断是否为回文串直到非回文或者扩展达到s的边界。记录下以该点为中心的最长回文子串的状态，start，end。 需要注意的是，对于 baad，如果默认中心为一个数（也就是奇数）那么就会判断失误，所以，我们还需要判断中心是偶数的情况。 最后综合奇数中心和偶数中心遍历出来的结果进行比较，然后得出最终结果。 动态规划的方法 遍历所有的两点之间的字符串是不是回文字符串，并且记录是回文字符串的状态，start和end。最后返回。这里需要建立records二维数组。 初始化该数组的时候，不能只初始化单个字符是回文串的部分，两个字符的也需要初始化，否则的话，两个的字符串需要在循环中单独处理，比较麻烦，代码也不优雅 使用两个字符串的最长公共子序列求解 转换思路如果我们转换一下思路，将s字符串反转，这个题就成了找到两个字符串的最长公共子序列，这就成了另一个题了，这个题就相对简单，可以使用动态规划来解决了。 3. 代码 3.1. C++实现 解法一 动态规划的办法 class Solution { public: string longestPalindrome(string s) { int n = s.length(); if (n == 0) {return \"\";} if (n == 1) {return s;} vector > records(n, vector(n, false)); int start = 0, max = 1; // 子串长度为1的回文长度是1，子串长度是2的，且两个字符相同的，回文长度是2 for (int i = 0; i 时间复杂度： O(n2) 空间复杂度： O(n) 解法二 中心扩展的办法 class Solution { public: // 中心扩展法 string longestPalindrome_2(string s) { int n = s.length(); if (n = 0 && end max) { max = len; is_even = true; center = i; } start--; end++; } } { // 中心是基数的情况, 基数和偶数并不是互斥的情况，基数是一定要考虑的 int start = i, end = i; while(start >= 0 && end max) { max = len; is_even = false; center = i; } start--; end++; } } } if (!is_even) { return s.substr(center - max/2, max); }else{ return s.substr(center - max/2 + 1, max); } } }; 时间复杂度： O(n2) 空间复杂度： O(1) 4. 总结 这个题的解法很多，其中最亮眼的还是新建一个反转字符串，然后求这两个字符串的最长公共子序列，这就成了另一个比较简单的题。掌握一个题的解法就可以解决其他的变种题！！！ "},"006-ZigZagConversion.html":{"url":"006-ZigZagConversion.html","title":"<>006-ZigZagConversion","keywords":"","body":"1. 题目描述（中等难度）2. 思路3. 代码3.1. C++ 实现4. 总结1. 题目描述（中等难度） https://leetcode.com/problems/zigzag-conversion/ 这个题目的意思是，给定一个字符串s和一个整数numRows,遍历该字符串中的所有字符按照N型，N型的边长是numRows。 2. 思路 在遍历s的时候定位出当前的字符应该存放到那个数组中，然后拼接数组。数组的纬度 numRows。 一开始我本想直接找到s的遍历指针i和对应数组下标的关系，但是尝试很长时间之后我发现我找不到。。。那么再仔细分析一下题目，画一下字符排列的路径。 从上图中可以看出，除了第一次向下之外，其余的上下运动轨迹都遵循上 numDowns - 1 和 下 numDows -1 的规律，那这不正和数组下标对应上了吗.在这个过程中我们只需要定义一个变量path， 改变亮在遍历的过程中代表数组的存储下标，而且和i无关，只和遍历的次数有关。 其实再仔细分析一下，第一次也不用搞特殊，我真是蠢了，这样也不用在边界上做特殊处理，path 也不会 numRows path = 0 vector records(3, \"\"); bool down = true for i = 0; i 3. 代码 3.1. C++ 实现 class Solution { public: string convert(string s, int numRows) { if (numRows records(numRows, \"\"); int n = s.length(); bool down = true; // 方向 int row = 0; for (int i = 0; i 4. 总结 对于这种找规律的题和边界情况复杂的题，需要静下来分析，不要一有点思路就开始写代码了 "},"007-ReverseInteger.html":{"url":"007-ReverseInteger.html","title":"007-ReverseInteger","keywords":"","body":"1. 题目描述（简单难度）2. 思路3. 代码4. 总结1. 题目描述（简单难度） https://leetcode.com/problems/reverse-integer/ 反转一个整数，溢出的话就返回0。 2. 思路 关于整数溢出的处理我们有两种方式，具体可以参考008-StringToIntegerAtoi. 但是这个题有个限制，我们只能使用 int类型的变量，所以这里不能使用long long int 判断溢出了。只能使用方法二。 3. 代码 class Solution { public: // 很丑陋的写法，不但使用了long long int 还使用了数组。 int reverse(int x) { long long int max = (long long int)((1 = 0) ? x : -x; bool flag = (x > 0) ? true : false; long long int quot = num / 10; int mod = num % 10; vector records; records.push_back(mod); while (quot != 0) { mod = quot % 10; quot = quot / 10; records.push_back(mod); } long long int result = 0; int j = records.size() - 1; for (int i = 0; i max) return 0; if (!flag && result > max + 1) return 0; } if (flag) return result; else return -result; } // 下面的写法和上面同样的效果，但是不用新建数组，还是使用了 long long int ，题目规定只能使用 int int reverse_2(int x) { long long int res = 0; int quot = x; while (quot) { int mod = quot % 10; quot = quot / 10; res = res * 10 + mod; if (res > INT_MAX || res INT_MAX / 10 || (res == INT_MAX / 10 && mod > INT_MAX % 10)) return 0; if (res 4. 总结 整数的反转，是不需要额外新建数组进行存储每一位的，关于溢出的判断可以参考008-StringToIntegerAtoi，还有上面的reverse_4 "},"008-StringToIntegerAtoi.html":{"url":"008-StringToIntegerAtoi.html","title":"008-StringToIntegerAtoi","keywords":"","body":"1. 题目描述（中等难度）2. 思路3. 代码3.1. C++ 实现4. 总结1. 题目描述（中等难度） https://leetcode.com/problems/string-to-integer-atoi/ 这个题就是实现 atoi, 对于数字字符前面的只能出现空格和'-', 对于超出整数范围[−231, 231 − 1]的数，需要返回对应的 -231 或者 231 2. 思路 去除字符串前缀的空格 判断第一个字符是不是 '-','+', 如果不是continue，是的话标记这是一个负(正)数 循环剩下的字符，直到出现非数字字符或者遍历完成。遍历的过程中计算 result，并且根据数字正负判断溢出。 3. 代码 3.1. C++ 实现 解法一 返回的结果使用 int 存储，溢出的判断比较麻烦 class Solution { public: int myAtoi(string str) { int n = str.size(), i = 0; int res = 0; bool flag = true; while(i '9' || str[i] INT_MAX / 10) || (res == INT_MAX / 10 && num > INT_MAX % 10))) return INT_MAX; if (!flag && ((-res '9' || str[i] INT_MAX / 10) || (res == INT_MAX / 10 && num > INT_MAX % 10))) return INT_MAX; if (!flag && ((-res 时间复杂度： O(n) 空间复杂度： O(1) 解法二 返回结果使用 long long int存储，溢出的判断简单 class Solution { public: int myAtoi(string str) { int n = str.size(), i = 0; long long int res = 0; bool flag = true; while(i '9' || str[i] INT_MAX) return INT_MAX; if (!flag && res - 1 > INT_MAX) return INT_MIN; } return (flag) ? res : -res; } }; 4. 总结 这个题的难度不大，考验人的地方是如何使用比较优美的代码实现边界的判断等等。比如上面优雅的实现溢出的判断。 整数溢出判断： 如果result的类型是int， 判断quot是不是大于 INT_MAX/10, 然后判断个位数 if (flag && ((res > INT_MAX / 10) || (res == INT_MAX / 10 && num > INT_MAX % 10))) return INT_MAX; if (!flag && ((-res 直接让 res 带符号并且进行判断，就不需要单独处理上面的负数溢出了，参考 007-ReverseInterger 如果 result 使用 long long int 存储, 可以先计算 res然后在进行溢出判断 res = res * 10 + num; // 如果 flag = false， 负值的最大值在这里会溢出，所以使用 long long int 来存储 res if (flag && res > INT_MAX) return INT_MAX; if (!flag && res - 1 > INT_MAX) return INT_MIN; "},"009-PalindromeNumber.html":{"url":"009-PalindromeNumber.html","title":"009-PalindromeNumber","keywords":"","body":"1. 题目描述（简单难度）2. 思路3. 代码4. C++ 实现4.1. 解法一5. 解法二6. 总结1. 题目描述（简单难度） https://leetcode.com/problems/palindrome-number/ 给定一个整数判断这个整数是不是一个回文整数。 2. 思路 思路一：我们可以计算出这个整数的回文整数，然后和原数字进行比较。这里需要注意的一点是，如果反转的数字使用int进行存储，那么就需要进行溢出的判断，但是这里没有要求使用int存储，我们采用long long int存储，这样就不需要判断溢出了。 思路二：可以计算出这个数的个位十位百位。。。然后存入一个数组中最后判断这个数组是不是一个回文数组。可以使用首尾数组指针进行判断。 3. 代码 4. C++ 实现 4.1. 解法一 计算出这个整数的回文整数，然后和原数字进行比较 class Solution { public: // 解法二, 计算出反向的值直接进行比较, 这里不判断溢出 bool isPalindrome_2(int x) { if (x 时间复杂度： O(1) 空间复杂度： O(1) 5. 解法二 class Solution { public: // 解法一, 通过求余存储每个值，从右到左，然后对vector进行对称检验 bool isPalindrome(int x) { if (x array; while(x) { int mod = x % 10; array.push_back(mod); x /= 10; } int i = 0, j = array.size() - 1; while(i 时间复杂度： O(n2) 空间复杂度： O(1) 6. 总结 对于反转整数，需要注意溢出的情况，使用更大容量的整型long long int 来存放反转结果，可以免去判断溢出的逻辑。 不使用 反转整数的做法，还可以计算整数的每一个位数存储到数组，然后进行相应的逻辑判断。这样就会多使用空间。 "},"011-ContainerWithMostWater.html":{"url":"011-ContainerWithMostWater.html","title":"011-ContainerWithMostWater","keywords":"","body":"1. 题目描述（中等难度）2. 思路3. 代码3.1. C++ 实现4. 总结1. 题目描述（中等难度） https://leetcode.com/problems/container-with-most-water/ 这个题是给定一组正整数(n >= 2)，每一个数在坐标上面表示高度，求这一组高度中，哪两个整数作为高度围住的水的容量最多。 2. 思路 围住的水的容量的计算公式是 w h（宽 高），一开始我尝试找到一个递推公式使用动态规划来解决，但是发现这个题并不复合最优子结构的性质，子状态最优并不能推出当前状态最优。 思路一：采用暴力搜索查的办法，计算所有的两两数字的组合组成的容量，然后找出最大的容量。时间复杂度 O(n2) 思路二：定义首尾两个指针,这样就保证了宽度最宽，然后计算首尾指针两个围城的容积。如果首比尾高那么，尾部前移，这样才能保证比前一个状态的容积可能大。 如果尾比首高，那么首部指针后移。如果相等的话就随意。这个过程中记录最大值返回。这种贪心实现。 3. 代码 3.1. C++ 实现 解法一 暴力搜索 class Solution { public: // 暴力搜索 O(n2) int maxArea(vector& height) { int n = height.size(); int max = 0; for (int i = 0; i max ? con : max; } } return max; } }; 时间复杂度： O(n2) 空间复杂度： O(1) 解法二 首尾指针逼近的贪心算法 class Solution { public: // https://leetcode.wang/leetCode-11-Container-With-Most-Water.html O(n)的时间复杂度 int maxArea_2(vector& height) { int n = height.size(); int start = 0, end = n - 1; int max = 0; while(start max) ? con : max; if (height[start] 时间复杂度： O(n) 空间复杂度： O(1) 4. 总结 对于不符合最优子结构的题目，除了暴力法之外，还要寻找贪心的解法，找到巧妙的解决办法，这个题就是控制变量，控制住w，改变h。减少变量的纬度。 "},"012-IntegerToRoman.html":{"url":"012-IntegerToRoman.html","title":"012-IntegerToRoman","keywords":"","body":"1. 题目描述（中等难度）2. 思路3. 代码3.1. C++实现4. 总结1. 题目描述（中等难度） https://leetcode.com/problems/integer-to-roman/ 这个题是第13题的一个逆向题，给定一个 1-3999 之间的整数，把它转换成一个 roman 字符串。 2. 思路 这种转换问题需要建一个表进行查询，通过查表来进行最终结果的拼接。 我们对给定的数字进行除法运算，分别获得给定数字的千位、百位、十位、个位，这个过程中分别查表找到对应的roman字符串,加到返回的结果中。 那么这个表里面应该放什么内容呢？首先想到的是用map来简历映射关系，key存放3000，2000，1000，900，800 ... 3,2,1，value存放对应的roman串 std::map records({ {3000, \"MMM\"}, {2000, \"MM\"}, {1000, \"M\"}, {900, \"CM\"}, {800, \"DCCC\"},{700, \"DCC\"},{600, \"DC\"},{500, \"D\"},{400, \"CD\"},{300, \"CCC\"},{200, \"CC\"},{100, \"C\"}, {90, \"XC\"}, {80, \"LXXX\"}, {70, \"LXX\"}, {60, \"LX\"}, {50, \"L\"}, {40, \"XL\"}, {30, \"XXX\"}, {20, \"XX\"}, {10, \"X\"}, {9, \"IX\"}, {8, \"VIII\"}, {7, \"VII\"}, {6, \"VI\"}, {5, \"V\"}, {4, \"IV\"}, {3, \"III\"}, {2, \"II\"}, {1, \"I\"} }); 这样每次进行查找的时候的时间复杂度是 O(logn) 当然还有更好的存储表的数据结构，数组！！！ 查询的时间复杂度是 O(1),如果建立一个一维的数组，因为要查询到3000，所以下标要到3000，这个存储容量是比较大的。 如果我们根据千位，百位，十位，个位进行纬度的划分，建立一个二维数组，就只需要 O(n) 的空间复杂度了 static const string s[4][10]= { {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"}, {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"}, {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"}, {\"\",\"M\",\"MM\",\"MMM\"}, }; 3. 代码 3.1. C++实现 解法一 使用map建表 class Solution { public: // 把所有的 能用到的拼接字符全部存入 map 中 string intToRoman(int num) { std::map records({ {3000, \"MMM\"}, {2000, \"MM\"}, {1000, \"M\"}, {900, \"CM\"}, {800, \"DCCC\"},{700, \"DCC\"},{600, \"DC\"},{500, \"D\"},{400, \"CD\"},{300, \"CCC\"},{200, \"CC\"},{100, \"C\"}, {90, \"XC\"}, {80, \"LXXX\"}, {70, \"LXX\"}, {60, \"LX\"}, {50, \"L\"}, {40, \"XL\"}, {30, \"XXX\"}, {20, \"XX\"}, {10, \"X\"}, {9, \"IX\"}, {8, \"VIII\"}, {7, \"VII\"}, {6, \"VI\"}, {5, \"V\"}, {4, \"IV\"}, {3, \"III\"}, {2, \"II\"}, {1, \"I\"} }); int j = 1000; std:string result = \"\"; while(j > 0) { int quot = num / j; num %= j; if (quot) result += records[quot * j]; j /= 10; } return result; } }; 时间复杂度： O(n) 空间复杂度： O(1) 解法二 使用二维数组建表查询 class Solution { public: // 把所有的 能用到的拼接字符全部存入 map 中 string intToRoman(int num) { // 不使用 map 使用数组来实现，借助数组的下标，这个人很秀，我还是太lj了~ string intToRoman_2(int num) { static const string s[4][10]= { {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"}, {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"}, {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"}, {\"\",\"M\",\"MM\",\"MMM\"}, }; return s[3][num/1000%10] + s[2][num/100%10] + s[1][num/10%10] + s[0][num%10]; } }; 时间复杂度： O(n) 空间复杂度： O(1) 4. 总结 虽然上面的时间复杂度和空间复杂度相同，但是使用数组进行查询的速度要比红黑树实现的map更快，使用hashmap占用更多的空间，所以在以后建表的时候 能使用数组和数组下标解决的优先使用该方式，不要以上来直接使用 map "},"013-RomanToInteger.html":{"url":"013-RomanToInteger.html","title":"<>013-RomanToInteger","keywords":"","body":"1. 题目描述（简单难度）2. 思路3. 代码3.1. C++ 实现4. 总结1. 题目描述（简单难度） 这个题目是给定一个roman字符串，计算出对应的数值 2. 思路 入手这个题目的核心思想就是查表，根据给定的roman字符和数字的对应关系，从头到尾遍历roman字符串，然后根据查表对应的数字，加到result中，最终返回即可。 那么这个表里面应该放什么内容呢？首先给定的 1,5,10,50,100,500,1000 肯定要在表里面。还有几个特殊的两个字符的也要放在表里面, 4:IV,9:IX,40:XL,90:XC,400:CD,900:CM 有了这个表就可以进行遍历查询了，查询的过程中注意是不是匹配 4，9，40等这几个两个字符的特殊数字。 3. 代码 3.1. C++ 实现 class Solution { public: int romanToInt(string s) { std::map records({ {\"M\", 1000}, {\"D\", 500}, {\"C\", 100}, {\"L\", 50}, {\"X\", 10}, {\"V\", 5}, {\"I\", 1}, {\"CM\", 900}, {\"CD\", 400}, {\"XC\", 90}, {\"XL\", 40}, {\"IX\", 9}, {\"IV\", 4} }); int i = 0, n = s.length(), result = 0; while (i 时间复杂度： O(n) 空间复杂度： O(1) 4. 总结 使用查表解决转换问题 "},"014-LongestCommonPrefix.html":{"url":"014-LongestCommonPrefix.html","title":"014-LongestCommonPrefix","keywords":"","body":"1. 题目描述（简单难度）2. 思路3. 代码3.1. C++ 实现1. 题目描述（简单难度） 给定一组字符串，找出字符串的最长公共前缀，没有的话返回\"\" 2. 思路 找出所有字符串的公共前缀，肯定要遍历所有的字符串，所有字符串一个字符一个字符的比较，直到有字符匹配字符串相应位置失败。 在这之前，我们可以找出这组字符串中最短字符，按照最短字符的长度进行遍历。 3. 代码 3.1. C++ 实现 //https://leetcode.com/problems/longest-common-prefix/ class Solution { public: string longestCommonPrefix(vector& strs) { int minlen = 10000; if (strs.size() == 0) return \"\"; string result = \"\"; for (auto tmp : strs) { minlen = (tmp.size() 时间复杂度： O(n) 空间复杂度： O(1) "},"015-3Sum.html":{"url":"015-3Sum.html","title":"015-3Sum","keywords":"","body":"1. 题目描述（中等难度）2. 思路3. 代码3.1. C++ 实现4. 总结1. 题目描述（中等难度） 给定一个整型数组，找出所有的三个数的组合，这三个数的和为0，结果数组不重复 2. 思路 要找出所有的组合，可以采用暴力搜索的办法三重循环，还要判断当前结果是不是已经在之前的结果中出现过。时间复杂度比较高。O(n3) 改进版暴力搜索：先对给定的数组进行排序，然后在进行遍历，这样对于循环体来说，如果当前的数之前遍历过，就不要再遍历了，因为找到的也是和之前重复的。并且在第一层循环的时候可以判断是不是>0,如果>0直接跳过，因为最小的大于0，和一定大于0. // 确定第一个数 for i = 0; i 0 break; // 没必要找了，最小都 大于 0 if (i > 0 && nums[i] == nums[i-1]) continue // 控制重复 // 确定第二个数 for j = i + 1; j i + 1 && nums[j] == nums[j - 1] continue // 控制第二个数重复, j>i+1 防止 0，0，0，0 情况的出现 target = 0 - nunms[i] - nums[j] // 确定第三个数 for k = j + 1; k 很遗憾上面这个方法超时了。 在确定第二个和第三个数的时候有没有更好的办法呢，上面的时间复杂度是 O(n2).因为已经对数组进行了排序，寻找最后两个数的时候，可以采取首尾指针逼近的方法， 如果首尾相加 \\> target，那么尾指针前移，这里可以加入重复控制，不加也行复杂度相同 如果首尾相加 \\3. 代码 3.1. C++ 实现 解法一 vector> threeSum_1(vector& nums) { vector > result; std::sort(nums.begin(), nums.end()); int n = nums.size(); // 1. 先确定第一个数 for (int i = 0; i 0) break; if (i > 0 && nums[i] == nums[i-1]) continue; // 2. 确定第二个数 for (int j = i + 1; j (i + 1) && nums[j] == nums[j - 1]) continue; int target = 0 - nums[i] - nums[j]; // 3. 确定第三个数 for (int k = j + 1; k {nums[i], nums[j], nums[k]}); break; } } } } return result; } 时间复杂度： O(n3) 空间复杂度： O(1) 解法一 // 优化一下上面找第二个和第三个数的算法，上面是循环遍历找，这里使用两个指针进行查找 vector> threeSum_2(vector& nums) { vector > result; std::sort(nums.begin(), nums.end()); int N = nums.size(); // 1. 先确定第一个数 for (int i = 0; i 0 && nums[i] == nums[i - 1]) continue; int num = 0 - nums[i]; // 2. 定义前后两个指针，往中间移动 int m = i + 1, n = N -1; while (m {nums[i], nums[m], nums[n]}); while(m 时间复杂度： O(n2) 空间复杂度： O(1) 4. 总结 对于整数数组的处理，如果没有排序可以先进行排序，然后再寻找突破口减少时间复杂度和重复判断逻辑的简化 对于排序的数组，查找的时候可以考虑首尾指针法，不要盲目暴力搜索 "},"016-3SumClosest.html":{"url":"016-3SumClosest.html","title":"016-3SumClosest","keywords":"","body":"1. 题目描述（中等难度）2. 思路3. 代码3.1. C++ 实现1. 题目描述（中等难度） 给定一个无序的整数数组，和target，找出三个数组中的数之和最接近target的结果。返回最接近的三个数的和。 2. 思路 这个题和3Sum同根同源，先进性排序。正常遍历第一个数，然后采取首尾指针中间逼近的方法，确定另外两个数。 3. 代码 3.1. C++ 实现 // 优化一下上面找第二个和第三个数的算法，上面是循环遍历找，这里使用两个指针进行查找 int threeSumClosest_2(vector& nums, int target) { int result = nums[0] + nums[1] + nums[2]; std::sort(nums.begin(), nums.end()); int N = nums.size(); int min_diff = INT_MAX; // 1. 先确定第一个数 for (int i = 0; i 0 && nums[i] == nums[i - 1]) continue; // 2. 定义前后两个指针，往中间移动 int m = i + 1, n = N -1; while (m 时间复杂度： O(n2) 空间复杂度： O(1) "},"017-LetterCombinationsOfAPhoneNumber.html":{"url":"017-LetterCombinationsOfAPhoneNumber.html","title":"017-LetterCombinationsOfAPhoneNumber","keywords":"","body":"1. 题目描述（中等难度）2. 思路3. DFS解法代码3.1. C++ 实现4. BFS解法代码4.1. C++ 实现5. 笛卡尔积实现5.1. Java 实现， 自定义相乘5.2. python 的 笛卡尔积实现 - map reduce1. 题目描述（中等难度） 给定一个拨号键盘，输入一串数字，输出这串数字对应键盘上的字母的所有的排列组合。 2. 思路 很明显这是一个全排列的问题。可以使用BFS或者DFS来进行遍历 使用深度优先遍历求解： 使用BFS广度优先遍历实现,BFS的实现需要借助队列来实现 使用笛卡尔积来进行实现 3. DFS解法代码 3.1. C++ 实现 使用递归实现DFS,遍历到底部然后回溯 class Solution { public: Solution() { records['2'] = \"abc\"; records['3'] = \"def\"; records['4'] = \"ghi\"; records['5'] = \"jkl\"; records['6'] = \"mno\"; records['7'] = \"pqrs\"; records['8'] = \"tuv\"; records['9'] = \"wxyz\"; } vector letterCombinations(string digits) { vector result; if (digits.length() == 0) { // 边界处理这个地方，必须返回一个 “” string， 不能直接返回一个空的 result, 否则结果为空 // result.push_back(\"\"); return result; } if (digits.length() == 1) { for (int i = 0; i records; }; 4. BFS解法代码 4.1. C++ 实现 BFS解法，一层层遍历，最终循环输出结果，可以使用 队列来实现 // https://leetcode.com/problems/letter-combinations-of-a-phone-number/ // 很明显这是一个排列组合题， 列出所有的组合可能，使用深度优先遍历算法 DFS class Solution { public: Solution() { records['2'] = \"abc\"; records['3'] = \"def\"; records['4'] = \"ghi\"; records['5'] = \"jkl\"; records['6'] = \"mno\"; records['7'] = \"pqrs\"; records['8'] = \"tuv\"; records['9'] = \"wxyz\"; } // 补充一个 BFS 的解法,使用队列实现 vector letterCombinations(string digits) { std::queue myqueue; std::vector result; if (digits.length() records; }; 5. 笛卡尔积实现 5.1. Java 实现， 自定义相乘 https://leetcode.wang/leetCode-17-Letter-Combinations-of-a-Phone-Number.html public List letterCombinations(String digits) { List ans = new ArrayList(); for (int i = 0; i getList(int digit) { String digitLetter[] = { \"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\" }; List ans = new ArrayList(); for (int i = 0; i mul(List l1, List l2) { if (l1.size() != 0 && l2.size() == 0) { return l1; } if (l1.size() == 0 && l2.size() != 0) { return l2; } List ans = new ArrayList(); for (int i = 0; i 5.2. python 的 笛卡尔积实现 - map reduce 见思路图三 "},"018-4Sum.html":{"url":"018-4Sum.html","title":"018-4Sum","keywords":"","body":"1. 题目描述（中等难度）2. 思路3. 代码3.1. C++实现1. 题目描述（中等难度） 给定一个无序的整数数组，和target，找出四个数组中的数之和等于target的结果。并且结果无重复。 2. 思路 这个题和3Sum其实是同一个题，先对数组进行排序，然后for循环遍历前两个元素，剩下的两个元素使用首尾指针中间逼近的方法进行选择。 3. 代码 3.1. C++实现 class Solution { public: vector> fourSum(vector& nums, int target) { std::vector > result; int n = nums.size(); std::sort(nums.begin(), nums.end()); for (int i = 0; i 0 && nums[i] == nums[i - 1]) continue; for (int j = i + 1; j i 比如 0,0,0,0 这个例子 if (j - 1 > i && nums[j] == nums[j - 1]) continue; // 构造两个指针前后夹击求解，这样就能将内层的 O(n2) 降到 O(n) int pstart = j + 1, pend = n - 1; while (pstart {nums[i], nums[j], nums[pstart], nums[pend]}); while (pstart 0) { pstart++; }else { pend--; } } } } return result; } }; 时间复杂度： O(n3) 空间复杂度： O(1) "},"019-RemoveNthNodeFromEndOfList.html":{"url":"019-RemoveNthNodeFromEndOfList.html","title":"019-RemoveNthNodeFromEndOfList","keywords":"","body":"1. 题目描述（简单难度）2. 思路3. 代码3.1. C++ 实现 总结1. 题目描述（简单难度） 只遍历一遍，删除单向链表的倒数第 n 个节点，返回链表头指针 2. 思路 抛开限制条件，我们可以先遍历一遍计算出一共有多少节点，然后第二遍遍历删除指定节点。 如果只遍历一遍的话，可以使用快慢指针的方法，快指针领先慢指针n个结点，然后同时遍历快慢指针，当快指针到达尾部的时候，慢指针指向的就是倒数第 n + 1个节点 3. 代码 3.1. C++ 实现 // 采用快慢指针的解法 class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { if (head == NULL || n == 0) return head; ListNode *slow = head, *fast = head; for (int i = 0; i next; else // 这一步其实没必要做，因为题目给的都是有效的 return head; } // 删除 头 的情况，如果fast最终指向 null ，说明要删除头指针 if (!fast) return head->next; while(fast->next) { slow = slow->next; fast = fast->next; } slow->next = slow->next->next; return head; } }; 时间复杂度： O(n) 空间复杂度： O(1) 总结 快慢指针在链表中的使用 "},"020-validparentheses.html":{"url":"020-validparentheses.html","title":"020-ValidParentheses","keywords":"","body":"1. 题目描述（简单难度）2. 思路3. 代码3.1. C++ 实现4. 总结1. 题目描述（简单难度） 这个题让判断是不是合法的圆括号组合 2. 思路 这个题可以使用栈来解决，遇到左边括号就入栈，遇到右边括号就检查栈顶元素，进行判断。 stack stk 1. 外层循环输入的字符串s, 循环变量 i：0 - n 2. IF s[i] == '(' || '{' || '[' : 入栈 s[i] ELSE: 如果 stk 是空的， 那么直接返回 false 否则的话 和栈顶元素进行比较，是不是 s[i] 对应的 左半边 如果和栈顶匹配， 出栈继续 否则返回 false 3. 如果 stk 为空，返会 true， 否则返回 false 3. 代码 3.1. C++ 实现 解法一 使用额外的map和set来存储用到的括号的映射关系，判断是不是左边类型的括号使用 set 来存储，判断栈顶元素和右边元素的映射关系使用 map 来实现 class Solution { public: Solution() { mymap[')'] = '('; mymap[']'] = '['; mymap['}'] = '{'; myset.insert('('); myset.insert('['); myset.insert('{'); } // 解法一， 使用了额外的 map 和 set 空间 bool isValid(string s) { std::stack mystack; for (int i = 0; i mymap; std::set myset; }; 时间复杂度： O(n) 空间复杂度： O(1) map 和 set 的空间 解法二 优化一下上面的数据结构，其实不需要 set 结构来判断，因为输入一定是合法的六个字符，直接使用switch 判断或者if就好了。往stack中push的时候不要直接放入 s[i]，而是存放对应的右边括号，这样每次判断的时候就不要找映射关系了 class Solution { // 解法二： switch case 节省空间 bool isValid_2(string s) { std::stack mystack; for (int i = 0; i 时间复杂度： O(n) 空间复杂度： O(1) 没有额外空间的使用 4. 总结 对于数量较少的固定集合，先不要忙着使用map或者set以及vector来存储，进行查找和存储，先想一下有没有其他的方式解决集合查找的问题，比如这个解法二中的 switch case。 "},"021-MergeTwoSortedLists.html":{"url":"021-MergeTwoSortedLists.html","title":"021-MergeTwoSortedLists","keywords":"","body":"1. 题目描述（简单难度）2. 思路2.1. 思路一2.2. 思路二3. 代码3.1. 解法一3.2. 解法二4. 总结1. 题目描述（简单难度） 合并两个排序链表 2. 思路 这里我们可以循环遍历两个链表，在循环比较中按照大小顺序把结点存入一个queue中，然后链接队列中的结点返回，这样的话就会额外使用一个队列的空间，还要遍历两边。下面介绍不使用额外空间并只遍历一遍的解法。 2.1. 思路一 定义两个指针，head和pcur，head指向返回的链表头。 首先要确定head和pcur的指向。分四种情况： case1： 当l1空l2非空 case2： 当l1空l2空 case3： 当l1非空l2空 case4： 当l1非空l2非空 在确定head的时候比较复杂。然后遍历两个链表，直到一个链表为空，pcur->next指向非空的链表。这里注意，pcur可能为空，如果其实链表有一个为空，pcur循环完之后就为空，这个需要特殊处理。 2.2. 思路二 上面思路一的边界情况比较多，很容易出错，这里我们采用带头结点的链表简化边界判断。 创建一个结点 head，里面存放的是 INT_MIN，这样就不用去确定head的指向问题，并且不会出现循环结束，pcur为空的情况。 3. 代码 3.1. 解法一 // 解法一， 头指针的确定很繁琐，条件很多 ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode *head = NULL, *pcur = NULL; while(l1 && l2) { if (pcur == NULL) { pcur = (l1->val val) ? l1 : l2; head = pcur; if (l1->val val) l1 = l1->next; else l2 = l2->next; continue; } if (l1->val val) { pcur->next = l1; l1 = l1->next; pcur = pcur->next; }else{ pcur->next = l2; l2 = l2->next; pcur = pcur->next; } } if (pcur == NULL) head = l1 ? l1 : l2; else pcur->next = l1 ? l1 : l2; return head; } 3.2. 解法二 // 解法二，使用类似带头结点的链表来实现，头结点存放 INT_MIN，这样返回的时候只需要返回头结点的next，不需要判断第一个结点是l1还是l2 ListNode* mergeTwoLists_2(ListNode* l1, ListNode* l2) { ListNode *head = new ListNode(INT_MIN), *pcur = head; while (l1 && l2) { if (l1->val val) { pcur->next = l1; l1 = l1->next; pcur= pcur->next; }else{ pcur->next = l2; l2 = l2->next; pcur= pcur->next; } } pcur->next = l1 ? l1 : l2; return head->next; } 时间复杂度： O(n) 空间复杂度： O(1) 4. 总结 链表的问题，当头结点边界条件很多的时候，可以创建一个带头结点的链表，简化边界处理 "},"022-GenerateParentheses.html":{"url":"022-GenerateParentheses.html","title":"<>022-GenerateParentheses","keywords":"","body":"1. 题目描述（中等难度）2. 思路2.1. 思路一2.2. 思路二3. 代码3.1. C++实现1. 题目描述（中等难度） https://leetcode.com/problems/generate-parentheses/ 2. 思路 2.1. 思路一 暴力求解法，每个位置上面有两个可能，穷举出每个位置的所有可能，然后判断最终的结果是不是合法。 时间复杂度比较高 O(2^2n), 一共有2n个坑位。 判断是不是合法： 是不是做括号等于右括号数 左边括号不能少于右边括号，在任意位置 2.2. 思路二 改进上面的判断逻辑，上面是等全部的位置都填完之后在进行判断，其实可以在遍历的过程中进行判断剪枝打到缩短时间复杂度的情况。 在遍历的过程中，每次填入一个字符的时候判断 左括号数是不是 > 右括号数， 如果是的话 cur[pos] = ')', 否则 return，结束当前递归 左括号是不是 3. 代码 3.1. C++实现 思路一 暴力法 class Solution { public: // 暴力搜索，时间复杂度太高了，需要列举每个位置上的所有的两种情况 vector generateParenthesis(int n) { int pos = 0; vector result; string cur(2*n, ' '); generateAll(n, pos, cur, result); return result; } void generateAll(int n, int pos, string cur, vector &result) { // 判断当前结果是不是符合规则 if (pos == n * 2) { int record = 0; for (int i = 0; i 时间复杂度： O(2^2n) 空间复杂度： O(n) 思路二 class Solution { public: // 优化判断条件不要在最后进行合法性的判断，进行剪枝 vector generateParenthesis_2(int n) { int pos = 0; vector result; string cur(2*n, ' '); int right = 0, left = 0; generateAll(n, pos, cur, result, left, right); return result; } void generateAll(int n, int pos, string cur, vector &result, int left, int right) { if (pos == 2 * n) { result.push_back(cur); return; } if (left }; ``` "},"023-MergeKSortedLists.html":{"url":"023-MergeKSortedLists.html","title":"*023-MergeKSortedLists","keywords":"","body":"1. 题目描述（困难难度）2. 思路2.1. 思路一2.2. 思路二2.3. 思路三3. 代码3.1. C++实现4. 总结1. 题目描述（困难难度） https://leetcode.com/problems/merge-k-sorted-lists/ 合并 k 个拍序好的单链表。 2. 思路 2.1. 思路一 可以使用递归来实现，之前做过merge两个拍序好的链表，请参考 021-MergeTwoSortedLists 这里我们可以使用递归实现，取出第一个链表，递归计算剩余 k-1 个链表的merge结果，然后按照合并两个链表的解法合并第一个和 2至k个链表的合并结果。递归结束的条件是lists的个数 2.2. 思路二 直接遍历一遍K个链表的所有结点，并且进行判断和链接，最后返回结果。 时间复杂度 O(nk)，(n 是最长链表的长度) 空间复杂度O(1) 2.3. 思路三 思路二中，查找一个最小值需要 O(K)的时间，使用堆结构存储可以达到时间复杂度 O(lng(k)); 使用优先队列存储链表，比较的规则是多有链表的head的val大小。 存储和插入的时间复杂度都是 log(k) 总的时间复杂度 N(log(k)), (N 是所有的结点个数) 3. 代码 3.1. C++实现 思路一 // 使用递归实现 ListNode* mergeKLists_2(vector& lists) { ListNode *ret = merge(lists, 0); return ret; } ListNode* merge(vector &lists, int pos) { if (pos == lists.size()) return NULL; if (pos == lists.size() - 1) return lists[pos]; ListNode *cur = new ListNode(0); ListNode *ret = cur; ListNode *list1 = lists[pos]; ListNode *list2 = merge(lists, pos+1); while (list1 || list2) { if (!list1) { cur->next = list2; break; } if (!list2) { cur->next = list1; break; } if (list1->val val) { cur->next = list1; list1 = list1->next; cur = cur->next; }else{ cur->next = list2; list2 = list2->next; cur = cur->next; } } return ret->next; } 思路二 ListNode* mergeKLists(vector& lists) { ListNode *head = new ListNode(0); ListNode *ret = head; while(1) { int min = INT_MAX; ListNode *cur = NULL; int pos = -1; for (int i = 0; i val val; pos = i;} } } if (!cur) break; lists[pos] = lists[pos]->next; head->next = cur; head = head->next; } return ret->next; } 时间复杂度： O(nk) 空间复杂度： O(1) 思路三 // 使用优先队列实现 class cmp { public: bool operator()(const ListNode *l1, const ListNode *l2) { return l1->val > l2->val; } }; ListNode *mergeKLists_3(vector& lists) { std::priority_queue, cmp> myqueue; ListNode *cur = new ListNode(0), *ret = cur; for (int i = 0; i next = node; cur = cur->next; node = node->next; myqueue.pop(); if (node != NULL) { myqueue.push(node); } } return ret->next; } 时间复杂度： O(Nlog(k)) 空间复杂度： O(1) 4. 总结 除了常规的递归和遍历之外，使用优先队列处理 K 排序问题，会节省很多时间。 "},"024-SwapNodesInPairs.html":{"url":"024-SwapNodesInPairs.html","title":"024-SwapNodesInPairs","keywords":"","body":"1. 题目描述（中等难度）2. 思路2.1. 思路一2.2. 思路二3. 代码3.1. C++实现3.2. 思路二4. 总结1. 题目描述（中等难度） https://leetcode.com/problems/swap-nodes-in-pairs/ 反转链表相邻元素 2. 思路 2.1. 思路一 递归求解, 单独处理前两个结点，后面的结点进行反转并且返回头结点。 2.2. 思路二 遍历一遍，直接反转完成。为了处理方便新建一个头指针结点空的。 3. 代码 3.1. C++实现 思路一 class Solution { public: // 递归实现 ListNode* swapPairs_2(ListNode* head) { if (!head || !head->next) return head; ListNode *ret = swapPairs_2(head->next->next); auto node = head->next; head->next = ret; node->next = head; return node; } }; 3.2. 思路二 class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode *n = new ListNode(0), *cur = n; n->next = head; while(cur->next && cur->next->next) { auto node1 = cur->next; auto node2 = cur->next->next; cur->next = node2; node1->next = node2->next; node2->next = node1; cur = node1; } return n->next; } }; 4. 总结 妙用头指针结点，可以免去单独处理head结点麻烦的逻辑。代码更清爽。 "},"026-RemoveDuplicatesFromSortedArray.html":{"url":"026-RemoveDuplicatesFromSortedArray.html","title":"026-RemoveDuplicatesFromSortedArray","keywords":"","body":"1. 题目描述（简单难度）2. 思路2.1. 思路一2.2. 思路二3. 代码3.1. C++ 实现4. 总结1. 题目描述（简单难度） https://leetcode.com/problems/remove-duplicates-from-sorted-array/ 给定一个拍序好的数组，返回这个数组中有多少个不重复的元素。并且再原来的数组中进行修改，将所有不同的数全部存放到前面中，因为是个数组的引用，所以leetcode很容易检验前面几个数是不是整个数组中不同的数据。 2. 思路 2.1. 思路一 一开始我想的办法是交换，但是想了一段时间发现交换的情况很复杂。于是放弃了。。。。 2.2. 思路二 这个思路其实类似快慢指针。 我们可以遍历一遍这个数组，然后把有多少不同的数计算出来，这样返回值就有了。时间复杂度O(log(n))，假设一共有k个不同的数 接下来，我们初始化一个 pos=1 ，指向当前需要修改的重复的数的位置。 记录i来遍历整个数组， 判断 nums[i] == nums[i - 1]; 如果相等的话，继续遍历，知道出现不相同的情况 nums[pos++] = nums[i] 执行这个操作，这样的话 i 始终领先于 pos 并不会出现重叠的情况。 总的时间复杂度也是 O(log(n)) 3. 代码 3.1. C++ 实现 class Solution { public: int removeDuplicates(vector& nums) { int total = 0, ret = 0; for (int i = 0; i 时间复杂度： O(n) 空间复杂度： O(1) 其实上面的循环可以合并成一个，让代码看起来更轻爽。（这是leetcode上面的人写的，很秀，和我想法一样但是比我的优雅 n 輩） int removeDuplicates_2(vector& A) { int count = 0, n = A.size(); for(int i = 1; i 4. 总结 对于数组元素的操作，并不是只有交换这一种思路，这个题并不要求我们改变完数组之后保持数组的元素和原来一样，所以我们这里可以借助快慢指针的思想来做这个题。 不要思维定势 "},"027-RemoveElement.html":{"url":"027-RemoveElement.html","title":"027-RemoveElement","keywords":"","body":"1. 题目描述（简单难度）2. 思路3. 代码3.1. C++实现4. 总结1. 题目描述（简单难度） https://leetcode.com/problems/remove-element/ 给一个数组，让找出所有不等于val值的个数返回。并且将非val值的元素放到数组的最前面元素中。 2. 思路 这个题和 026-RemoveDuplicatesFromSortedArray是类似的，如出一辙，这里我们依然采用快慢指针实现，pos用于指向前k个非val的数，pos从0到k，i则是遍历nums数组的快指针没遇到val值就直接前进。遇到非val的值就设置 nums[pos++] = nums[i]；i继续前进直到nums.size(); 在上面这个循环中定义一个整数ret记录非 val 值的个数。用于返回。 这样我们没有使用额外的数组来存储中间结果，在原来数组上面直接修改，边可以满足要求。 总的时间复杂度是 O(n)) 3. 代码 3.1. C++实现 class Solution { public: int removeElement(vector& nums, int val) { int pos = 0, ret = 0; for (int i = 0; i = nums.size()) break; nums[pos++] = nums[i]; ret++; } return ret; } }; 时间复杂度： O(n) 空间复杂度： O(1) 4. 总结 数组链表问题，在进行求解的时候，如果题目要求不使用额外的数组空间，空间复杂度比较苛刻O(1),那么就可以考虑快慢指针来实现。 "}}