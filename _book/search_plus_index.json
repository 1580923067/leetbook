{"./":{"url":"./","title":"Introduction","keywords":"","body":" 介绍 介绍 leetcode地址： https://leetcode.com/ leetcode中国地址：https://leetcode-cn.com/ github地址：https://github.com/smbzhang/leetcode "},"001-TwoSum.html":{"url":"001-TwoSum.html","title":"001-TwoSum","keywords":"","body":"1. 题目描述（简单难度）2. 解法一2.1. C++实现2.2. Go实现2.3. Python实现3. 解法二3.1. C++实现4. 总结1. 题目描述（简单难度） Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 2. 解法一 简单粗暴，两重循环，外层遍历下标 i：[0，n - 1)，内层 j：[i + 1，n - 1]。n是数组的长度 2.1. C++实现 class Solution { public: vector twoSum(vector& nums, int target) { vector result; int n = nums.size(); for (int i = 0; i 2.2. Go实现 func twoSum(nums []int, target int) []int { var ret []int for i := 0; i 2.3. Python实现 class Solution(object): def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" ret = [] n = len(nums) for i in range(0, n - 1): for j in range(i + 1, n): if nums[i] + nums[j] == target: ret.append(i) ret.append(j) return ret return ret 时间复杂度：两层 for 循环，O（n²） 空间复杂度：O（1） 3. 解法二 第二个循环是为了找出 target-nums[i] 的值，代替循环我们可以使用hash map来存储数组信息 key：数组的值 value：数组的下标 3.1. C++实现 class Solution2 { public: vector twoSum(vector& nums, int target) { vector result; int n = nums.size(); std::unordered_map hmap; for (int i = 0; i second != i) { result.emplace_back(i); result.emplace_back(iter->second); break; } } return result; } }; 空间换时间，额外使用了一个 4. 总结 "},"002-AddTwoNumbers.html":{"url":"002-AddTwoNumbers.html","title":"002-AddTwoNumbers","keywords":"","body":"1. 题目描述（中等难度）2. 思路3. 代码3.1. C++实现3.2. python实现3.3. Go实现1. 题目描述（中等难度） 2. 思路 这个题就是一个大数加法题，两个链表表示两个大数字，不过链表的节点是按照数字的低位到高位进行排列的，所以我们从头遍历两个链表并把结点值相加，进位用carry表示。伪代码如下： 1. 初始化两个NULL节点 pcur 和 ret， ret用来返回结果链表，pcur指向当前操作的结果链表节点 2. 初始化一个int类型的进位值 carry = 0 3. 初始化两个int类型的值，表示当前两个链表的当前元素的值， num1 = 0 num2 = 0 4. while(l1 != NULL || l2 != NULL) 1. num1 = (l1 == NULL) ? 0 : l1->val 2. num2 = (l2 == NULL) ? 0 : l2->val 3. 计算 mod = num1 + num2 + carry % 10 4. 计算 carry = num1 + num2 + carry / 10 如果 pcur 等于 NULL 5. 新建一个 node 节点，使用 mod 初始化， 并且 pcur 指向这个节点， ret = pcur 初始化返回列表头 否则的话 5. 新建一个 node 节点，使用 mod 初始化， 并且 pcur->next 指向这个节点, pcur = node 6. 判断 l1 和 l2 是否为 NULL 并向前移动一个节点 5. 判断 carry 是不是0，如果不是的话，创建一个节点node使用carry初始化，pcur指向这个node 6. 返回 ret 时间复杂度 O(n) 空间复杂度O(1) 3. 代码 3.1. C++实现 下面两个其实实现是一样的，只不过第一个没有使用 num1和num2来进行设计，所以写出来的程序很丑陋。 class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *pcur1 = l1, *pcur2 = l2, *pcur = NULL, *ret = NULL; int carry = 0; while (pcur1 != NULL) { int num1 = pcur1->val; if (pcur2 != NULL) { int num2 = pcur2->val; int mod = (num1 + num2 + carry) % 10; if (pcur == NULL) { pcur = new ListNode(mod); ret = pcur; }else { ListNode *node = new ListNode(mod); pcur->next = node; pcur = node; } carry = (num1 + num2 + carry) / 10; pcur2 = pcur2->next; }else break; pcur1 = pcur1->next; } while(pcur1 != NULL) { int mod = (pcur1->val + carry) % 10; carry = (pcur1->val + carry) / 10; ListNode *node = new ListNode(mod); pcur->next = node; pcur = node; pcur1 = pcur1->next; } while(pcur2 != NULL) { int mod = (pcur2->val + carry) % 10; carry = (pcur2->val + carry) / 10; ListNode *node = new ListNode(mod); pcur->next = node; pcur = node; pcur2 = pcur2->next; } if (carry != 0) { ListNode *node = new ListNode(carry); pcur->next = node; pcur = node; } return ret; } }; class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *ret = NULL, *pcur = NULL; int num1 = 0, num2 = 0, carry = 0; while (l1 != NULL || l2 != NULL) { num1 = (l1 == NULL) ? 0 : l1->val; num2 = (l2 == NULL) ? 0 : l2->val; int mod = (num1 + num2 + carry) % 10; carry = (num1 + num2 + carry) / 10; ListNode *node = new ListNode(mod); if (pcur == NULL) { pcur = node; ret = pcur; } else { pcur->next = node; pcur = node; } if (l1 != NULL) l1 = l1->next; if (l2 != NULL) l2 = l2->next; } if (carry != 0) { ListNode *node = new ListNode(carry); pcur->next = node; } return ret; } }; 3.2. python实现 class Solution(object): def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" ret = None pcur = ret num1 = 0 num2 = 0 carry = 0 while l1 != None or l2 != None : if l1 == None: num1 = 0 else: num1 = l1.val if l2 == None: num2 = 0 else: num2 = l2.val mod = (num1 + num2 + carry) % 10 carry = (num1 + num2 + carry) / 10 node = ListNode(mod) if pcur == None: pcur = node ret = pcur else: pcur.next = node pcur = node if l1 != None: l1 = l1.next if l2 != None: l2 = l2.next if carry != 0: node = ListNode(carry) pcur.next = node return ret 3.3. Go实现 func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { var pcur, ret *ListNode = nil, nil var num1, num2, carry int = 0, 0, 0 for l1 != nil || l2 != nil { if (l1 == nil) {num1 = 0} else {num1 = l1.Val} if (l2 == nil) {num2 = 0} else {num2 = l2.Val} mod := (num1 + num2 + carry) % 10 carry = (num1 + num2 + carry) / 10 node := new(ListNode) node.Val = mod node.Next = nil if (pcur == nil) { pcur = node ret = node }else { pcur.Next = node pcur = node } if (l1 != nil) {l1 = l1.Next} if (l2 != nil) {l2 = l2.Next} } if (carry != 0) { node := new(ListNode) node.Val = carry node.Next = nil pcur.Next = node } return ret } "},"003-LongestSubstringWithoutRepeatingCharacters.html":{"url":"003-LongestSubstringWithoutRepeatingCharacters.html","title":"003-LongestSubstringWithoutRepeatingCharacters","keywords":"","body":"1. 题目描述（中等难度）2. 思路3. 代码3.1. C++实现3.2. Go语言实现3.3. Python实现1. 题目描述（中等难度） 这个题让找出最长的子串，该子串里面没有重复的字母 2. 思路 看到这个题，首先想到的是动态规划来解，求出以i开头的最长无重复子串，从这些子串中找出最长的。其中以i开头的最长无重复子串是和以i+1开始的最长无重复子串有相应关系的，可以列出递推公式。 1. 循环求出以i开头的最长无重复子串长度 2. 根据递推公式写出计算以i开头的无重复子串的最大长度程序。 3. 代码 3.1. C++实现 //动态规划递归求解, Memory Limit Exceeded class Solution { public: int lengthOfLongestSubstring(string s) { int max = 0; for (int i = 0 ; i max) ? len : max; } return max; } int lengthOfTheFirstSub(string str, int index) { string s = str.substr(index); if (s.length() 使用最简单的递归实现动态规划算法，leetcode显示内存超出限制，递归深度太高了，对于非常长的字符串。 //加入记录数组，提升查找速度, Memory Limit Exceeded 一定程度上解决内存问题 class Solution { public: int lengthOfLongestSubstring(string s) { int max = 0; std::vector records(s.length(), -1); for (int i = 0 ; i max) ? len : max; } return max; } int lengthOfTheFirstSub(string str, int index, std::vector &records) { if (records[index] != -1) {return records[index];} string s = str.substr(index); if (s.length() 上面的程序通过加入记录数组来解决每次递归都重新计算重复的以i开头的最长无重复子串，这样可以减少递归的深度，并且减少时间复杂度。很遗憾对于长字符串还是内存超限了，所以我们必须干掉递归程序 // 改成递推求解，减少栈内存消耗 class Solution { public: int lengthOfLongestSubstring(string s) { int n = s.length(); std::vector records(n, 0); if (n = 0; i--) { if (s[i] == s[i + 1]) { records[i] = 1; }else{ int index = s.substr(i + 1, records[i + 1]).find(s[i]); if (index == string::npos) { records[i] = records[i + 1] + 1; }else { records[i] = index + 1; } } } int max = 0; for (int i = 0; i max) { max = records[i]; } } return max; } }; 改造成递推求解，这样时间复杂度就是O(n), 空间复杂度也是O(n)，顺利通过leetcode检查 3.2. Go语言实现 func lengthOfLongestSubstring(s string) int { n := len(s) if (n = 0; i-- { if (s[i] == s[i + 1]) { records[i] = 1; }else{ if (!strings.Contains(s[i + 1: i + 1 + records[i +1]], string(s[i]))) { records[i] = records[i + 1] + 1; }else { index := strings.Index(s[i + 1: i + 1 + records[i +1]], string(s[i])) records[i] = index + 1 } } } max := 0 for _, num := range(records) { if num > max {max = num} } return max } 3.3. Python实现 class Solution(object): def lengthOfLongestSubstring(self, s): \"\"\" :type s: str :rtype: int \"\"\" n = len(s) if n max: max = records[i] return max "},"020-validparentheses.html":{"url":"020-validparentheses.html","title":"020-ValidParentheses","keywords":"","body":"1. 题目描述（简单难度）2. 思路3. 代码3.1. C++ 实现4. 总结1. 题目描述（简单难度） 这个题让判断是不是合法的圆括号组合 2. 思路 这个题可以使用栈来解决，遇到左边括号就入栈，遇到右边括号就检查栈顶元素，进行判断。 stack stk 1. 外层循环输入的字符串s, 循环变量 i：0 - n 2. IF s[i] == '(' || '{' || '[' : 入栈 s[i] ELSE: 如果 stk 是空的， 那么直接返回 false 否则的话 和栈顶元素进行比较，是不是 s[i] 对应的 左半边 如果和栈顶匹配， 出栈继续 否则返回 false 3. 如果 stk 为空，返会 true， 否则返回 false 3. 代码 3.1. C++ 实现 解法一 使用额外的map和set来存储用到的括号的映射关系，判断是不是左边类型的括号使用 set 来存储，判断栈顶元素和右边元素的映射关系使用 map 来实现 class Solution { public: Solution() { mymap[')'] = '('; mymap[']'] = '['; mymap['}'] = '{'; myset.insert('('); myset.insert('['); myset.insert('{'); } // 解法一， 使用了额外的 map 和 set 空间 bool isValid(string s) { std::stack mystack; for (int i = 0; i mymap; std::set myset; }; 时间复杂度： O(n) 空间复杂度： O(1) map 和 set 的空间 解法二 优化一下上面的数据结构，其实不需要 set 结构来判断，因为输入一定是合法的六个字符，直接使用switch 判断或者if就好了。往stack中push的时候不要直接放入 s[i]，而是存放对应的右边括号，这样每次判断的时候就不要找映射关系了 class Solution { // 解法二： switch case 节省空间 bool isValid_2(string s) { std::stack mystack; for (int i = 0; i 时间复杂度： O(n) 空间复杂度： O(1) 没有额外空间的使用 4. 总结 对于数量较少的固定集合，先不要忙着使用map或者set以及vector来存储，进行查找和存储，先想一下有没有其他的方式解决集合查找的问题，比如这个解法二中的 switch case。 "}}