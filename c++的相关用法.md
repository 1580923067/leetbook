# C++ 用法笔记

## 为什么C++模板函数的定义和实现只能写在同一个.h文件中

如果模板函数的定义和实现分别写在.h和.cpp文件中，编译阶段是没有问题的，因为编译单元是单个的cpp文件。对于有模板定义的cpp文件来说，模板函数是一种不完整的定义.编译器不知道模板函数的具体类型，无法为其生成代码。对于模板函数只有在调用的地方才知道如何生成代码。

这样就会导致，其他cpp文件引用模板函数的头文件，在编译的阶段没有问题，因为编译器会在实现这个地方做符号标记，等到链接阶段的时候会到模板函数的相应.o文件中查找相应实例化后的函数代码，因为编译阶段确定为不完整定义而没有真正生成代码，所以在链接阶段的时候就会报错。

![](/assets/cpp-001.jpg)

## throw 和 noexception

C++11中建议使用 noexception 代替 throw，因为c++17以后throw相关的所有用法就被废弃了

```
void except_func() throw(int, double) 
定义了一个动态异常声明throw(int, double)，该声明指出了excpt_func可能抛出的异常的类型。事实上，该特性很少被使用，因此在C++11中被弃用了

而表示函数不会抛出异常的动态异常声明throw()也被新的noexcept异常声明所取代。
1. void noexcept_func() throw() {}
2. void noexcept_func() noexcept (ture) {}
3. void noexcept_func() noexcept (false) {}

1 等价于 2
2 表示该函数不允抛出异常，如果该函数中有异常抛出的话，程序会直接调用 std::terminate 终止程序的运行
3 不阻止该函数抛出异常

noexcept形如其名地，表示其修饰的函数不会抛出异常。不过与throw()动态异常声明不同的是，在C++11中如果noexcept修饰的函数抛出了异常，

编译器可以选择直接调用std::terminate()函数来终止程序的运行，这比基于异常机制的throw()在效率上会高一些。

这是因为异常机制会带来一些额外开销，比如函数抛出异常，会导致函数栈被依次地展开（unwind），并依帧调用在本帧中已构造的自动变量的析构函数等。
```

![](/assets/cpp-002.jpg)

## 为什么析构函数不能抛出异常呢

more effective c++提出两点理由：

1. 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。

2. 通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。

![](/assets/cpp-003.jpg)

上面的例子很好的解释了为什么析构函数不能抛出异常。如果在一个catch块中，打开栈之后析构其中的对象，这个时候抛出异常,程序再次去那个寄存器找链表头，但是链表头已经被丢弃了，这个时候程序就找不到之前的catch块。
