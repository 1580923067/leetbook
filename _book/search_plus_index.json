{"./":{"url":"./","title":"Introduction","keywords":"","body":" 介绍 介绍 leetcode地址： https://leetcode.com/ leetcode中国地址：https://leetcode-cn.com/ github地址：https://github.com/smbzhang/leetcode "},"chapter1.html":{"url":"chapter1.html","title":"LeetCode_1_TwoSum(两数之和)","keywords":"","body":"1. 题目描述（简单难度）2. 解法一2.1. C++实现2.2. Go实现2.3. Python实现3. 解法二3.1. C++实现4. 总结1. 题目描述（简单难度） Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 2. 解法一 简单粗暴，两重循环，外层遍历下标 i：[0，n - 1)，内层 j：[i + 1，n - 1]。n是数组的长度 2.1. C++实现 class Solution { public: vector twoSum(vector& nums, int target) { vector result; int n = nums.size(); for (int i = 0; i 2.2. Go实现 func twoSum(nums []int, target int) []int { var ret []int for i := 0; i 2.3. Python实现 class Solution(object): def twoSum(self, nums, target): \"\"\" :type nums: List[int] :type target: int :rtype: List[int] \"\"\" ret = [] n = len(nums) for i in range(0, n - 1): for j in range(i + 1, n): if nums[i] + nums[j] == target: ret.append(i) ret.append(j) return ret return ret 时间复杂度：两层 for 循环，O（n²） 空间复杂度：O（1） 3. 解法二 第二个循环是为了找出 target-nums[i] 的值，代替循环我们可以使用hash map来存储数组信息 key：数组的值 value：数组的下标 3.1. C++实现 class Solution2 { public: vector twoSum(vector& nums, int target) { vector result; int n = nums.size(); std::unordered_map hmap; for (int i = 0; i second != i) { result.emplace_back(i); result.emplace_back(iter->second); break; } } return result; } }; 空间换时间，额外使用了一个 4. 总结 "},"chang-yong-shu-ju-jie-gou-shu-li.html":{"url":"chang-yong-shu-ju-jie-gou-shu-li.html","title":"常用数据结构梳理","keywords":"","body":"1. HashMap无序Map1.1. C++的hash_map & unordered_map1.2. 特性1.3. hash_table 与 Bucket1.4. 迭代器1.5. 构造方式1.6. 容量操作1.7. 元素操作1. HashMap无序Map 1.1. C++的hash_map & unordered_map 这两个的内部结构都是使用哈希表来实现的，区别是 unordered_map 在 C++11中被引入标准库了。 1.2. 特性 关联性：通过key去检索value，而不是通过绝对地址（和顺序容器不同） 无序性：使用hash表存储，内部无序 Map : 每个值对应一个键值 键唯一性：不存在两个元素的键一样 动态内存管理：使用内存管理模型来动态管理所需要的内存空间 1.3. hash_table 与 Bucket unorderedmap的内部是使用 hashtable 数据结构存储的，hash就会存在冲突，关于怎么处理冲突可以去看一下STL源码剖析这本书。 当出现冲突的时候会通过链表连在前一个元素后面，这个位置被称为bucket 所以unordered_map内部其实是由很多哈希桶组成的，每个哈希桶中可能没有元素，也可能有多个元素。 1.4. 迭代器 unordered_map的迭代器是一个指针，指向这个元素，通过迭代器来取得它的值。 unordered_map::iterator it; (*it).first; // the key value (of type Key) (*it).second; // the mapped value (of type T) (*it); // the \"element value\" (of type pair) 它的键值分别是迭代器的first和second属性。 it->first; // same as (*it).first (the key value) it->second; // same as (*it).second (the mapped value) 1.5. 构造方式 - 构造空的容器 - 复制构造 - 范围构造 - 用数组构造 typedef unordered_map stringmap; int main () { stringmap first; // 空 stringmap second ( {{\"apple\",\"red\"},{\"lemon\",\"yellow\"}} ); // 用数组初始 stringmap fourth (second); // 复制初始化 stringmap sixth (second.begin(),second.end()); // 范围初始化 for (auto& x: sixth) cout 1.6. 容量操作 empty bool empty() const noexcept; size size_type size() const noexcept; 1.7. 元素操作 find iterator find ( const key_type& k ); 查找key所在的元素。 找到：返回元素的迭代器。通过迭代器的second属性获取值 没找到：返回unordered_map::end insert 插入有几种方式： 复制插入 (复制一个已有的pair的内容) 数组插入（直接插入一个二维数组） 范围插入（复制一个起始迭代器和终止迭代器中间的内容） 数组访问模式插入(和数组的[]操作很相似) 具体看后面的例子 at mapped_type& at ( const key_type& k ); 查找key所对应的值 如果存在：返回key对应的值，可以直接修改，和[]操作一样。 如果不存在：抛出 out_of_range 异常. erase 擦除元素也有几种方式： 通过位置（迭代器）iterator erase ( const_iterator position ); 通过keysize_type erase ( const key_type& k ); 通过范围（两个迭代器）iterator erase ( const_iterator first, const_iterator last ); clear void clear() noexcept 清空unordered_map swap void swap ( unordered_map& ump ); 交换两个unordered_map（注意，不是交换特定元素，是整个交换两个map中的所有元素） "}}